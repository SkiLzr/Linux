\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{fancyhdr}
\usepackage {setspace}
\pagestyle{fancy}
\fancyhead{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{1pt}
\renewcommand{\baselinestretch}{1.05}
\begin{document}
\title{ Linux Résumé} 
 \maketitle 
\author{Willy et Bastien}\\\\
{\large\textbf{Les 7 premières commandes}}\\\\
- whoaim : elle renvoie votre login- name actuel.\\
- hostname : elle renvoie le nom de la machine sur laquelle vous travaillez.\\
- date : elle renvoie la date actuelle.\\
- uname : elle renvoie des informations sur le système actuel.\\
- passwd :  elle permet au user de changer son mot de passe.\\
- elle permet à l’administrateur ou le root de changer le mot  de passe d’un user. \\
- touch : elle permet la création d’un fichier vide ou la mise à jour de la date de modification d’un fichier existant.\\
- last : elle renvoie la liste des utilisateurs qui se sont récemment connectés au système\\\\
{\large\textbf{Obtenir de l’aide avec l’attribut « - - help »}}\\\\
- COMMANDE - [LinuxAttributs] - - [UnixAttributs] \\
- Exemple : uname - a \\
- Exemple : date - - help \\
- Vous remarquerez que les attributs Linux n’ont qu’un seul « - » \\
- Vous remarquerez que les attributs Unix ont deux « - - » \\\\
{\large\textbf{Obtenir de l’aide avec la commande man}}\\\\
 La commande man s’utilise avec la syntaxe suivante :  \\
- man [Nom section] [nom de la commande recherchée] \\
Dans le cas où vous ne connaissez pas la section relative à la commande recherchée, vous pouvez vous rabattre sur cette forme de syntaxe : \\
- man - a [nom de la commande recherchée] \\
- Le « - a » pour « all » permettra a man de renseigner toutes les sections.\\\\
{\large\textbf{Obtenir de l’aide avec la commande man}}\\\\
Une fois l’interface man lancée on y distingue :  \\\\
- Différents paragraphes relatifs au nom, à la syntaxe, à l’usage, aux exemples, etc\\
- man possède une fonction de recherche pour naviguer à travers les différents paragraphes\\  /[mots pouvant se trouver dans le texte] \\
- Exemple : /examples \\
- Vous dirigera dans le paragraphe examples \\\\
{\large\textbf{Comprendre les outils du « Shell »}}\\\\
- En Linux, il existe trois canaux principaux :\\
- STDIN : c’est l’entrée standard (généralement le clavier) \\
- STDOUT : c’est la sortie standard (généralement l’écran)\\ 
- STDERR : c’est le canal d’erreur (généralement vers un fichier)\\\\\\
 {\large\textbf{Comprendre les outils du « Shell » suite }}\\\\
Les pipes « | » : \\
- En Linux le pipe permet de rediriger la sortie d’une commande dans l’entrée d’une seconde afin que la deuxième commande effectue un traitement sur le résultat de la première  : \\\\
- Exemple : ici la sortie de ls (qui retourne la liste des éléments du dossier courant) qui est redirigée vers l’entrée de grep (qui effectue une recherche sur base d’une chaîne de caractère) \\\\
{\large\textbf{L’arborescence du système de fichier}}\\\\
- Chaque arborescence de fichier en Linux prend toujours naissance avec le « root directory » ou « / » \\
- Depuis le « / » l’arborescence se dessine autour de dossiers fondamentaux pour le fonctionnement du système \\\\
{\large\textbf{L’arborescence du système de fichier suite}}\\\\
- Ce système de fichier peut être héberger sur un seul device de stockage - HDD - SSD \\
- Cependant, il est courant et conseillé d’isoler certains dossiers sur des devices différents.\\
- Le principe du mount est donc de connecter des parties du système de fichier à la représentation du système de stockage.\\\\
{\large\textbf{Lister les fichiers avec ls}}\\\\
- Lister les fichiers en Linux est essentiel puisque nous travaillons principalement en ligne de commandes. \\
- ls : renvoie la liste des fichiers et des dossiers présents dans le répertoire courant. \\
- ls - l : renvoie la liste des fichiers et des dossiers présents dans le répertoire courant avec leurs propriétés.\\
- ls - a : renvoie la liste de tous les fichiers et des dossiers présent dans le répertoire courant. \\\\
{\large\textbf{Utiliser les SHELL wildcarts }}\\\\
- Le SHELL Linux possède la capacité de globbing : \\
- C'est-à-dire que le SHELL est capable d’interpréter des symboles de remplacements dans les commandes. \\
- * remplace plusieurs caractères inconnus.\\
- ? : remplace un caractère inconnu.\\
- [a- 9] : remplace un caractère par un des caractères du « range » défini\\\\
{\large\textbf{Copier un fichier avec la commande cp}}\\\\
Pour copier un fichier ou un dossier d’un emplacement à l’autre dans l’arborescence de fichiers, vous devez utiliser la commande : \\\\
- Pour un fichier : cp [SOURCE] [DESTINATION] \\
- Pour un dossier : cp - R [SOURCE] [DESTINATION]\\\\
{\large\textbf{Travailler avec les dossiers }}\\\\
- La commande cd : (change directory) \\
- elle permet de se déplacer dans le système.\\
- La commande mkdir : (make directory)\\
- elle permet de créer un dossier dans le système.\\
- La commande rmdir : (remove directory)  \\
- elle permet de supprimer un dossier dans le système.\\\\\\\\\\
{\large\textbf{Utiliser les chemins absolus et relatifs }}\\\\
- Un chemin absolu est un chemin qui commence à la racine du système de fichier. \\
- Dans notre cas cette racine est « / » aussi appelé « root ». \\\\
Exemple : \\
/home/admin/Documents/ \\
- Un chemin relatif est un chemin qui commence à la position actuelle dans le système de fichier.\\\\
- Exemple : si vous vous trouvez dans /home/admin pour accéder à un dossier dans /home/admin/Documents/ , il suffit de repartir de votre position actuelle.\\ 
- Documents/UTILITIES\\\\
{\large\textbf{Déplacer un fichier avec la commande mv }}\\\\
- Techniquement il est possible de déplacer un fichier avec la commande cp mais celle- ci à le désavantage de conserver une version du fichier à l’emplacement originel.\\ 
- Pour cela la commande mv a la capacité de recopier le fichier dans une autre partie de l’arborescence de fichier tout en effaçant le fichier de son emplacement originel \\\\
Pour un fichier : mv [SOURCE] [DESTINATION] \\\\
- Il est à noter que d’un point de vue système, renommer un fichier revient à déplacer(mv) ou copier ce fichier(cp) avec un autre nom dans une [DESTINATION == SOURCE]\\\\
{\large\textbf{Supprimer un fichier ou un dossier avec la commande rm}}\\\\
- La suppression de fichiers ou de dossiers en Linux se fait par le simple appel à la commande rm \\
- Cependant, cette commande peut s’avérer dangereuse pour votre système si vous l’utilisez mal. \\
- Pour supprimer un fichier : rm [SOURCE] \\
- Pour supprimer un dossier : rm - r [SOURCE] \\
- Pour supprimer un dossier sans confirmation : rm - rf [SOURCE] \\
- rm - rf [SOURCE] est une commande incroyablement dangereuse pour le système Linux si elle n’est pas utilisée correctement. \\\\
- Si elle est activée à la racine du système « / » avec les droits « root » alors elle effacera l’entièreté de l’arborescence de fichiers et donc tout le système sans demander de confirmation de l’administrateur. \\\\
- rm - rf / : est donc une commande de wipe complet du système\\\\
{\large\textbf{Comprendre le Hard- Link et le Symbolic- Link}}\\\\
- Les systèmes Linux possèdent une caractéristique très utiles que l’on appel « Link »\\
- Il existe deux types de « Link » \\
- Le Hard- Link est un nom qui référence un « inode » qui lui- même référence un bloc sur le périphérique de stockage.\\
- Le symbolic- Link : est un nom qui référence un Hard- link\\\\
{\large\textbf{Créer un link avec la commande ln }}\\\\
- Pour créer un « Link » dans un système Linux, vous devez utiliser la commande ln \\
- Peu importe que vous vouliez créer un Hard- Link ou un Symbolic- Link \\\\
- ln [SOURCE] [LINK- NAME] : permet de créer un HARD- LINK \\
- ln - s [SOURCE] [LINK- NAME] : permet de créer un Symbolic- Link\\\\\\\\\\\\
{\large\textbf{Trouver un fichier avec la commande find }}\\\\
- Pour configurer certains services ou simplement pour exécuter un script, il est nécessaire de trouver le fichier de configuration ou le fichier script dans le système de fichier. \\\\
- Cela peut s’avérer difficile étant donné la quantité de fichier contenue dans un OS. \\
- Heureusement Linux possède une commande très intéressante pour cela find \\\\
- find [START- POINT] - name « [FILENAME] » : \\permet de chercher un fichier/dossier de manière récursive grâce à son nom à partir du point de départ.\\  \\
- find [START- POINT] - user « [USERNAME] » : \\permet de chercher tous les fichiers/dossiers appartenant à un utilisateur de manière récursive grâce au nom de l’utilisateur à partir du point de départ. \\\\
{\large\textbf{Comprendre « VIM » }}\\\\
- Pour éditer un fichier texte avec « VIM » vous devez utiliser la commande vim  \\
- vim [SOURCE DU FICHIER] \\
- vim fonctionne sous 3 modes distinct : \\
- Le mode « command » : permet de sauvegarder, quitter, rechercher … \\
- Le mode « insert » : permet d’éditer le texte ... \\
- Le mode « visual » : permet d’effectuer des sélections dans le texte ... \\
- Il est très important de comprendre que chaque action ne peut se faire que dans le mode qui lui est dédié\\\\
{\large\textbf{Travailler avec le pager less }}\\\\
- Le contenu d’un fichier peut- être conséquent et pas forcément facile à lire dans un « SHELL » .\\
- less est une commande qui à la capacité d’organiser le texte en page pour le « SHELL ».  \\
- less [SOURCE] \\
- Pour utiliser le pager, il suffit de connaître ceci : \\
- La navigation ,de page en page, se fait avec page- up et page- down \\
- Vous pouvez effectuer une recherche comme dans « VIM » avec :/[mot recherché] \\
- Vous quittez le pager en appuyant sur la touche [q] \\\\
{\large\textbf{Lire un fichier texte grâce à cat et tac}}\\\\
- Certain fichiers texte sont suffisamment court pour ne pas requérir à less \\
- Il est alors plus utile d’utiliser des commandes qui ne font que présenter le contenu du fichier en le « SHELL » \\
- cat [SOURCE] : présente le fichier dans le « SHELL »\\
- tac [SOURCE] : présente le fichier dans le « SHELL » en commençant par la fin.\\\\
{\large\textbf{Lire le début ou la fin d’un fichier avec head et tail }}\\\\
- Il n’est souvent pas nécessaire de lire l’entièreté d’un fichier.\\
- Par exemple dans un fichier de logging c’est souvent les dernières lignes qui nous intéressent. \\
- head - n[nombre de lignes] [SOURCE] : présente les 10 premières lignes du fichier dans le « SHELL » \\
- tail - n[nombre de lignes] [SOURCE] : présente les 10 dernières lignes du fichier dans le « SHELL »\\\\
{\large\textbf{Lire le début ou la fin d’un fichier avec head et tail suite}}\\\\
- Une option intéressante pour observer un fichier de log est l’attribut - f \\
- tail - f [SOURCE] : présente les 10 dernière lignes du fichier dans le « SHELL » et les actualise à chaque changement dans le fichier\\
\newpage
{\large\textbf{Travailler avec la commande grep en dehors de |}}\\\\
grep est une des commandes les plus utiles en Linux.  \\
elle permet de trouver une correspondance entre une expression et un texte contenu dans un fichier. \\\\
Exemple : vous cherchez tous les fichiers ou il est écrit « dhcp » dans votre système. \\
grep -iR [Expression recherchée] 2>/dev/null \\\\
-i : attribut qui rend grep case insensitive \\
-R : attribut qui permet à grep de travailler de manière récursive \\
2>/dev/null : redirection des erreurs dans le /dev/null \\\\
grep est une des commandes les plus utiles en Linux.  \\
elle permet de trouver une correspondance entre une expression et un texte contenu dans un fichier. \\\\
Exemple : vous cherchez tous les fichiers ou il est écrit « dhcp » dans votre système. \\grep -iR [Expression recherchée] 2>/dev/null \\
-i : attribut qui rend grep case insensitive \\
-R : attribut qui permet à grep de travailler de manière récursive \\
2>/dev/null : redirection des erreurs dans le /dev/null \\\\
{\large\textbf{Travailler en « root » ou en « local user » }}\\\\
- En Linux, il existe fondamentalement deux types d’utilisateurs du système.\\ 
- Le super- utilisateur « root » : il est tout puissant sur le système \\
- L’utilisateur normal « local user » \\
- La connexion en tant que « root » est possible sur le système. \\
- A condition de connaître le mots passe du « root » \\
- Il est à noter que tant qu’il est possible de ne pas travailler en « root », il est déconseillé de s’y connecter.\\
- Il est possible de se connecté en tant que « root » uniquement dans un « SHELL » précis et pas sur tout l’environnement grâce à la commande sudo - i ou grâce à sudo su - \\\\
{\large\textbf{Utiliser la commande su  }}\\\\
- Comme vu au slide précédent, il est possible d’utiliser la commande su – pour se connecter au « SHELL » en tant que « root ».\\
- Mais en réalité, vous pouvez vous connecter à n’importe quelle utilisateur avec cette commande, pour autant que vous ayez des droits d’administration (ou de sudoers) comme dit en Linux\\\\
{\large\textbf{La commande sudo : }}\\\\
Pour réaliser des opérations admin \\
Toutes les tâches admin peuvent être lancées par un « sudoers » en utilisant la commande sudo \\
Il est nécessaire d’avoir les droits “sudoers” pour utiliser sudo et donc d'être dans le groupe wheel\\\\
Exemple : sudo dnf install texmaker (installe le logiciel texmaker)\\
Pour vérifier le groupe dans lequel est un user \\
La commande  : id [USERNAME] \\
Exemple : id skilz\\\\
{\large\textbf{Ajouter un user à un groupe :}}\\\\
La commande : usermod - aG [GROUP] [USERNAME]\\
Exemple : sudo usermod - aG wheel bob\\\\\\\\\\
{\large\textbf{Créer une configuration personnalisée de sudo}}\\\\
Sur linux il existe un fichier où sont répertoriés les droits de sudo. Il faut appartenir au groupe wheel pour avoir ces droits là\\
Il est possible de modifier ce fichier grâce à la commande visudo\\
La commande visudo ouvre le fichier sudo avec « VIM » et permet d’y effectuer des changements. 
{\large\textbf{Connexion à distance à un système Linux}}\\\\
Dans l’IT, il est courant de devoir se connecter à distance sur une machine\\
il existe deux solutions en Linux : \\\\
* ssh (connexion sécurisée à distance)\\
* telnet (connexion non sécurisée et souvent absente maintenant des système Linux modernes)\\\\
Exemple : \\
* ssh [username]@[ip- address]\\
* ssh [username]@[hostname] \\\\
{\large\textbf{La gestion des utilisateurs}}\\\\
Créer un « user » avec la commande useradd\\
Créer un « group » avec la commande groupadd\\\\
{\large\textbf{Pourquoi les users sont nécessaires ? }}\\\\
* Il est impossible de se connecter si vous n’utilisez pas un « user » \\
* Tout processus démarré dans le système appartient à un « user »\\
* Dans un système Linux pour accéder à une ressource, il faut un « account » et donc indirectement être un « user » du système. \\\\
{\large\textbf{Comprendre le rôle de l’appartenance}}\\\\
La commande : ls - alh  permet de lister tous les fichiers d’une manière lisible dans un dossier\\
Quand un « user » crée un fichier ou un dossier, il devient automatiquement en propriétaire ainsi que son groupe primaire.\\
La commande : touch nomfichier (permet de créer un fichier)\\
La commande : id permet d’afficher les infos users (votre identifiant, votre nom de user, votre groupe primaire et vos groupes secondaire)\\\\
{\large\textbf{Créer un « user » avec la commande useradd }}\\\\
- Pour créer un « user » vous devez utiliser la commande : \\
- useradd [OPTIONS] [LOGIN]  \\
- useradd est une commande très riche avec énormément d’option. \\\\
- Je vous conseil d’utiliser useradd - - help afin de vous guider dans son utilisation \\
- Créer un « user » sans choisir d’options particulières. \\
- useradd [LOGIN] \\\\
- Créer un « user » en ajoutant un commentaire. \\
- useradd - c ‘mon premier user account’ [LOGIN] \\\\
- Créer un « user » en permettant la création du /home directory. \\
- useradd - m [LOGIN] \\\\
- Créer un « user » en lui attribuant un autre groupe primaire que lui même (attention le groupe doit déjà exister). \\
- useradd - g [GROUPE] [LOGIN]  \\\\
- Créer un « user » en lui attribuant des groupes secondaires (attention les groupes doivent déjà exister). \\
- useradd - G [GROUPES] [LOGIN] \\\\
{\large\textbf{Créer un « groupe » avec la commande groupadd }}\\\\
- Pour créer un « groupe » vous devez utiliser la commande : \\
- groupadd [OPTIONS] [GROUPE]  \\\\
- groupadd est une commande moins riche que useradd avec moins d’options. \\
- Je vous conseil d’utiliser groupadd - - help afin de vous guider dans son utilisation\\
- On remarque clairement qu’il existe peu d’options (attributs) pour groupadd.\\\\
- Dans tous les attributs, un seul à une utilisations commune c’est - g \\
- groupadd - g [GROUPE] : permet de spécifier le groupe ID (GID) désiré pour le groupe. Sinon celui- ci est choisi aléatoirement dans les ID disponibles sur le système \\
- groupadd - g [GROUPE]\\\\
- usermod [OPTIONS] [LOGIN] :  \\
- usermod - g [NEW PRIMARY GROUP] [LOGIN] : change le groupe primaire du « user »  \\
- usermod - G [LIST OF SECONDARY GROUP] [LOGIN] : écrase la liste des groupes secondaires du « user » pour la remplacer par la nouvelle.  \\
- usermod - aG [LIST OF SECONDARY GROUP] [LOGIN] : ajoute sans écrasé à la liste des groupes secondaires du « user » les nouveaux groupes. \\\\
{\large\textbf{La suppression d’un « user » est une opération simple :}}\\\\
- Il suffit d’appeler la commande suivant userdel [OPTIONS] [LOGIN] :  \\
- userdel - r [LOGIN] : supprime le compte du « user » ainsi que son répertoire personnel.\\\\
{\large\textbf{La suppression d’un « groupe » est une opération simple :}}\\\\
- Il suffit d’appeler la commande suivant groupdel [OPTIONS] [LOGIN] : \\
- groupdel [LOGIN] : supprime le groupe. - groupdel - f [LOGIN] : supprime le groupe même si c’est un « primary group » appartenant à un « users »\\\\
{\large\textbf{Modifier les propriétés d’un « groupe » existant :}}\\\\
- On à vu qu’il était possible de modifier un « user » déjà créé, il en va de même pour les « groupes »  \\
- groupmod [OPTIONS] [GROUP] : \\
- groupmod - g [group] : change le GID du groupe.\\\\
- Lors de sa création, un « user » prend certaines valeurs par défauts. Ces valeurs par defaut sont visibles grâce à la commande useradd - D \\\\
- Cette commande en réalité renvoie ce qui est écrit dans une fichier configuration dans /etc/default/useradd. -vim /etc/default/useradd\\\\
{\large\textbf{La gestion des « users/groups »: Ajouter et gérer les passwords }}\\\\
- PASSWD : Cette commande permet l’ajout d’un password à un user account mais aussi de pouvoir changer tout les champs de /etc/shadow/ \\
-  passwd [OPTIONS] login  - OPTIONS : \\
- « - l » : Lock : verrouille le compte en ajoutant un ! Devant le mot de passe crypté  \\
- « - u » : Unlock : déverrouille le compte  \\
- « - d » : Supprime le password du compte \\
- « - n » : Durée de vie minimal en jours du password \\
- « - x » : Durée de vie maximale en jours du password \\
- « - w » : Nombre de jours avant avertissement \\
- « - i  » : Délai e grâce avant désactivation si le password est expiré \\
- « - S » : Statut du compte \\\\ 
{\large\textbf{CHAGE : }}\\\\
- Cette commande permet approximativement les mêmes opérations que PASSWD mais avec une lisibilité plus grande.  \\
- chage [OPTIONS] login - OPTIONS : \\
- « - m » : Mindays : équivaut à passwd - n \\
- « - M » : Maxdays : équivaut à passwd - x \\
- « - d » : Date de la dernière modification du password (depuis 01/01/1970) \\
- « - E » : Date d’expiration du password (depuis 01/01/1970) \\
- « - I » : (Inactive)\\
- « - W » : Warndays : équivaut à passwd - w (Nombre de jours avant avertissement) \\\\
/etc/passwd: Le fichier passwd contient la liste des utilisateurs et est en accès non restreint. \\\\
- Il contient 7 champs : - Login : password : UID : GID : comment : homedir : shell\\\\
- /etc/group: Le fichier « group » contient la définition des groupes et la liste des utilisateurs qui en font partie. \\\\
- /etc/shadow: Le fichier shadow accompagne le fichier /etc/passwd et c’est là que sont stockés, entre autres, les passwords cryptés des utilisateurs ainsi que les informations relatives à leur validité. \\\
- /etc/gshadow : C’est le pendant du fichier /etc/shadow mais pour les groupes. Il n’est cependant pas supporté dans certaines distributions LINUX anciennes.\\\\
- La création des utilisateurs peut être entièrement effectuée à la mains en travaillant sur les fichiers car ce sont des fichiers plats. \\\\
- etc/passwd - etc/shadow - etc/group \\
- etc/gshadow \\
- Mais cela est absolument déconseillé et à ne pas faire!\\\\
{\large\textbf{Gérer les permissions standards en Linux  }}\\\\
- Pour changer les permissions sur un « file » ou un « folder » il faut utiliser la commande chmod [permissions] [PATH]  \\\\
- Il est possible de travailler avec la méthode « UGO »\\ 
Exemple : chmod [UGO permissions] [PATH] \\\\
- Il est possible de travailler avec la méthode « octal » \\
Exemple :chmod [octal permissions] [PATH] \\\\
{\large\textbf{Gérer les permissions spéciale en Linux }}\\\\
- Pour changer les permissions spéciales sur un « file » ou un « folder » il faut utiliser la commande chmod [permissions] [PATH] \\\\
- Il est possible de travailler avec la méthode « UGO » chmod [UGO permissions] [PATH]  \\
- u+s : active SUID - g+s : active SGID \\
- +t : active le STICKY BIT -\\
- Il est possible de travailler avec la méthode « octal » chmod [special permissions][octal permissions] [PATH] \\
- 4 : active SUID \\
- 2 : active SGID \\
- 1 : active STICKY BIT\\
{\large\textbf{Utiliser setfacl pour gérer les (ACL) }}\\\\
- Pour définir une access list en Linux, nous devons utiliser la commande setfacl \\
-setfacl - Rm [Permissions Modification] [File/FOLDER PATH]  \\\\
- C’est par l’intermédiaire de cette commande que nous allons orienter le type d’ACL configuré.\\ \\
-Normal : appliquée sur les files déjà existant  \\
-Default : appliquée sur les files qui seront nouvellement créé. \\\\
{\large\textbf{Connaitre le status ACL d’un file/folder }}\\\\
- Il est tout à fait possible de vérifier les ACL déjà placées sur un item présent dans l’arborescence de\\ fichier grâce à la commande 
 : getfacl [File/FOLDER PATH] \\\\
{\large\textbf{Comprendre les attributs étendus}}\\\\
- Il existe 2 commandes relatives à la gestion des attributs étendus \\
-lsattr : pour lister les attributs étendus des fichiers\\
-chattr : pour changer les attributs étendus des fichiers \\\\
{\large\textbf{La gestion des Quotas }}\\\\
- De manière générale, on ne veut pas qu'un seul utilisateur puisse occuper tout l'espace disque, \\
il faut alors définir des « quotas » qui apporteront une limitation en terme d'espace disque utilisé.  \\\\
- La gestion des « quotas » peut aussi être utilisée au niveau des groupes. \\
- Deux types de limites possibles  \\
- Block : Limite sur la taille du dossier \\
- Soft : Limite que l'utilisateur/groupe peut dépasser pendant un certain temps.\\
- Hard : Limite que l'utilisateur/groupe ne pourra jamais dépasser. \\
- Inodes : Limite sur le nombre de fichiers (dossiers) \\
- Soft : Limite que l'utilisateur/groupe peut dépasser pendant un certain temps. \\
- Hard : Limite que l'utilisateur/groupe ne pourra jamais dépasser.\\\\
{\large\textbf{La gestion des Quotas : Mode d’emplois en « Ext4 »}}\\\\
- Consulter le rapport :\\
La commande repquota - a donné l'état actuel des quotas \\\\
{\large\textbf{Appliquer une configuration réseau « run time » }}\\\\
- Quand on travail sur la configuration réseau Linux, il est important de distinguer \\
- La configuration « run time » conçue pour monitorer les paramètres et pour effectuer des tests.  \\
- La configuration persistante faites pour fournir à votre machine un accès permanent et fiable au réseau. \\\\
{\large\textbf{Configuration « run time » : voir les interfaces }}\\\\
- Pour voir les interfaces réseau disponibles sur votre système: \\ 
vous devez utiliser la commande ip link \\
- Pour voir les interfaces réseaux disponibles et leur adresse vous devez utiliser \\
- ip address show : \\\\\\\\\\\\\\
{\large\textbf{Configuration « run time » : Connaitre la default getaway }}\\\\
- Dernière commande essentielle afin de connaître la « default getaway » de vos interfaces : ip route show  \\\\
{\large\textbf{Appliquer une configuration réseau persistance}}\\\\
- Pour créer une configuration réseau persistante sur une distribution Linux, il existe un grand panel de programmes de gestion réseau. \\
- De tous, le plus courant et le plus complet est nmcli  \\
- nmcli est une commande tellement riche, qu’il est nécessaire d’utiliser au maximum l’outil d’auto- complétion du « Bash » \\\\
{\large\textbf{Deux outils diagnostiques importants : « ping »  et « dig » }}\\\\
- Un fois la votre configuration réseau effectuée, il est important de s’assurer que celle- ci soit fonctionnelle. \\
- Pour s’en assurer, il existe deux outils intéressant et facile à utiliser en Linux \\
- Pour tester la connectivité d’une interface : ping [IP ADRESS / HOSTNAME]  \\
- Pour vérifier l’activité du serveur « dns » et la validité d’un « hostname » : dig [HOSTNAME] \
{\large\textbf{Comprendre le firewalling sous Linux  }}\\\\
- Les « firewall » sont une couche supplémentaire de sécurité visant à protéger vos systèmes. \\
- Typiquement, ils sont installés sur les routeurs de vos réseaux afin de protéger celui- ci des connexions entrantes non désirées. \\
- Cependant sur les systèmes Linux individuels, cette couche est intégrée et utilisable par l’intermédiaire de votre « CLI ». \\
- Le processus de firewalling en Linux est géré par Netfilter et est directement intégré au « Kernel » \\
- Netfilter travaille par filtre des « process informations » et gère les capacités « input » « output » « forward » dans le kernel. \\
- Afin de manipuler netfilter, il faut passer par la commande iptables \\
- iptables est une commande extrêmement riche, qu’il est difficile de maîtriser sans pratiquer régulièrement \\
- C’est pour cela que les différents distributions on créé des commandes plus simple en surcouche de iptables afin de faciliter l’utilisation du « firewalling » sur machines individuelles. \\
- Dans le cadre de ce cours, nous verrons la surcouche firewall- cmd commune aux distributions RedHat, Centos, Fedora \\\\
{\large\textbf{Comprendre les basiques de iptables}}\\\\
- Avant de commencer à manipuler iptables, il est important de comprendre la structure de la commande. \\
- En iptables, on travail sur les échanges qui ont lieu entre : \\
-INPUT : pour les paquets entrants  \\
-OUTPUT : pour les paquets sortant  \\\\
{\large\textbf{Travailler avec firewall- cmd }}\\\\
- firewall- cmd est une surcouche à iptables et permet de manière plus simple gérer les « INPUT » et les « OUTPUT » sur votre système. \\\\
-firewall- cmd - - add- service ssh (version runtime)  \\
-firewall- cmd - - add- service ssh - - permanent (version persistante)  \\\\
- Pour maintenant supprimer l’utilisation d’un service et l’empêcher de communiquer à travers le « firewall » \\
-firewall- cmd - - remove- service ssh - - permanent (version persistante)  \\\\
- Après avoir imposé une nouvelle règle, il est essentiel de reload le service « firewalld » avec la commande firewall- cmd –reload\\
\end{document}